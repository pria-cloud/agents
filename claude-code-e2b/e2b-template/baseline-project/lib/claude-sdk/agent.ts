// Claude Code SDK Agent Integration
// This service orchestrates Claude Code SDK operations for intelligent development workflows

import { cookies } from 'next/headers'
import createServerClient from '@/lib/supabase/server'
import { ClaudeAgent as ClaudeCodeSDK } from '@anthropic-ai/claude-code'
import { e2bSandboxService } from '@/lib/services/e2b'
import type { 
  Requirement, 
  TechnicalSpec, 
  ClaudeOperationInsert,
  GeneratedFileInsert,
  SessionHistoryInsert 
} from '@/lib/supabase/types'

export interface ClaudeAgentConfig {
  sessionId: string
  workspaceId: string
  projectPath: string
  githubRepoUrl?: string
  githubBranch?: string
}

export interface CodeGenerationRequest {
  requirements: Requirement[]
  techSpecs?: TechnicalSpec[]
  targetFiles?: string[]
  generateTests?: boolean
}

export interface CodeGenerationResult {
  generatedFiles: {
    path: string
    content: string
    type: string
    description: string
  }[]
  testsGenerated: boolean
  documentsUpdated: string[]
  errors?: string[]
}

export class ClaudeAgent {
  private config?: ClaudeAgentConfig
  private supabase: ReturnType<typeof createServerClient>
  private claudeSDK: ClaudeCodeSDK

  constructor(config?: ClaudeAgentConfig) {
    this.config = config
    const cookieStore = cookies()
    this.supabase = createServerClient(cookieStore)
    
    // Initialize Claude Code SDK
    this.claudeSDK = new ClaudeCodeSDK({
      apiKey: process.env.ANTHROPIC_API_KEY!,
      workspaceDir: config?.projectPath || '/tmp/claude-workspace',
      tools: ['edit', 'read', 'bash', 'computer']
    })
  }

  /**
   * Analyze requirements and generate technical specifications
   */
  async analyzeRequirements(requirements: Requirement[]): Promise<TechnicalSpec[]> {
    const operationId = await this.logOperation('analyze_requirements', {
      requirement_ids: requirements.map(r => r.id),
      requirements_count: requirements.length
    }, this.config?.sessionId, this.config?.workspaceId)

    try {
      // Use Claude Code SDK for requirement analysis
      const analysisPrompt = this.buildRequirementAnalysisPrompt(requirements)
      
      const claudeResponse = await this.claudeSDK.chat(analysisPrompt)
      
      // Parse Claude's response to extract technical specifications
      const techSpecs: TechnicalSpec[] = this.parseAnalysisResponse(claudeResponse, requirements)
      
      // Technical specs are now generated by Claude Code SDK
      // The parseAnalysisResponse method handles the conversion

      // Save technical specs to database
      const { data: savedSpecs, error } = await this.supabase
        .from('technical_specs')
        .insert(techSpecs.map(spec => ({
          session_id: spec.session_id,
          workspace_id: spec.workspace_id,
          requirement_id: spec.requirement_id,
          category: spec.category,
          title: spec.title,
          description: spec.description,
          implementation_details: spec.implementation_details,
          code_examples: spec.code_examples,
          dependencies: spec.dependencies,
          generated_by_claude: spec.generated_by_claude
        })))
        .select()

      if (error) {
        throw new Error(`Failed to save technical specs: ${error.message}`)
      }

      await this.completeOperation(operationId, { tech_specs_generated: savedSpecs?.length || 0 })
      
      return savedSpecs || []
    } catch (error) {
      await this.failOperation(operationId, error instanceof Error ? error.message : 'Unknown error')
      throw error
    }
  }

  /**
   * Generate code from requirements and technical specifications
   */
  async generateCode(request: CodeGenerationRequest): Promise<CodeGenerationResult> {
    const operationId = await this.logOperation('generate_code', {
      requirements_count: request.requirements.length,
      tech_specs_count: request.techSpecs?.length || 0,
      generate_tests: request.generateTests || false
    }, this.config?.sessionId, this.config?.workspaceId)

    try {
      // Use Claude Code SDK for actual code generation
      const codeGenPrompt = this.buildCodeGenerationPrompt(request)
      
      const claudeResponse = await this.claudeSDK.generateCode(codeGenPrompt, {
        fileTypes: ['tsx', 'ts', 'json'],
        framework: 'nextjs',
        testFramework: request.generateTests ? 'vitest' : undefined
      })
      
      const generatedFiles: CodeGenerationResult['generatedFiles'] = this.parseCodeGenerationResponse(claudeResponse)
      
      // Files are now generated by Claude Code SDK and parsed from response
      // The parseCodeGenerationResponse method handles file extraction

      // Save generated files to database
      const fileInserts: GeneratedFileInsert[] = generatedFiles.map(file => ({
        session_id: this.config.sessionId,
        workspace_id: this.config.workspaceId,
        file_path: file.path,
        file_type: file.type,
        content: file.content,
        generated_from_requirement_id: request.requirements[0]?.id || null,
        created_by_claude: true
      }))

      const { error } = await this.supabase
        .from('generated_files')
        .upsert(fileInserts, { onConflict: 'session_id,file_path' })

      if (error) {
        console.error('Failed to save generated files:', error)
      }

      const result: CodeGenerationResult = {
        generatedFiles,
        testsGenerated: request.generateTests || false,
        documentsUpdated: ['README.md', 'API_DOCS.md']
      }

      await this.completeOperation(operationId, result)
      
      return result
    } catch (error) {
      await this.failOperation(operationId, error instanceof Error ? error.message : 'Unknown error')
      throw error
    }
  }

  /**
   * Update existing code based on requirement changes
   */
  async updateCode(requirementId: string, changes: Partial<Requirement>): Promise<CodeGenerationResult> {
    const operationId = await this.logOperation('update_code', {
      requirement_id: requirementId,
      changes
    }, this.config?.sessionId, this.config?.workspaceId)

    try {
      // Use Claude Code SDK to analyze and update existing code
      const updatePrompt = this.buildCodeUpdatePrompt(requirementId, changes)
      
      const claudeResponse = await this.claudeSDK.updateCode(updatePrompt, {
        requirementId,
        changes,
        preserveExisting: true
      })
      
      const result: CodeGenerationResult = this.parseCodeUpdateResponse(claudeResponse)

      await this.completeOperation(operationId, result)
      return result
    } catch (error) {
      await this.failOperation(operationId, error instanceof Error ? error.message : 'Unknown error')
      throw error
    }
  }

  /**
   * Log a Claude operation start
   */
  private async logOperation(
    operationType: string, 
    inputData: any, 
    sessionId?: string, 
    workspaceId?: string
  ): Promise<string> {
    const finalSessionId = sessionId || this.config?.sessionId
    const finalWorkspaceId = workspaceId || this.config?.workspaceId

    if (!finalSessionId || !finalWorkspaceId) {
      console.error('Missing session ID or workspace ID for operation logging')
      return crypto.randomUUID() // fallback ID
    }

    const { data, error } = await this.supabase
      .from('claude_operations')
      .insert({
        session_id: finalSessionId,
        workspace_id: finalWorkspaceId,
        operation_type: operationType,
        input_data: inputData,
        status: 'in-progress'
      })
      .select()
      .single()

    if (error) {
      console.error('Failed to log operation:', error)
      return crypto.randomUUID() // fallback ID
    }

    return data.id
  }

  /**
   * Mark operation as completed
   */
  private async completeOperation(operationId: string, outputData: any): Promise<void> {
    await this.supabase
      .from('claude_operations')
      .update({
        status: 'completed',
        output_data: outputData,
        completed_at: new Date().toISOString()
      })
      .eq('id', operationId)
  }

  /**
   * Mark operation as failed
   */
  private async failOperation(operationId: string, errorMessage: string): Promise<void> {
    await this.supabase
      .from('claude_operations')
      .update({
        status: 'failed',
        error_message: errorMessage,
        completed_at: new Date().toISOString()
      })
      .eq('id', operationId)
  }

  /**
   * Execute code files in the E2B sandbox environment
   */
  async executeCode(request: {
    files: any[]
    entryPoint: string
    sessionId: string
    workspaceId: string
  }): Promise<{
    success: boolean
    output: string
    errors?: string[]
    executionTime: number
  }> {
    const operationId = await this.logOperation('execute_code', {
      entry_point: request.entryPoint,
      files_count: request.files.length,
      session_id: request.sessionId
    }, request.sessionId, request.workspaceId)

    const startTime = Date.now()

    try {
      // Use real E2B sandbox execution
      if (!request.files.length) {
        throw new Error('No files provided for execution')
      }

      const entryFile = request.files.find(f => f.file_path === request.entryPoint)
      if (!entryFile) {
        throw new Error(`Entry point file not found: ${request.entryPoint}`)
      }

      // Create or get existing sandbox
      let sandboxSession = await e2bSandboxService.createSandbox(request.sessionId, {
        template: process.env.E2B_TEMPLATE_ID || 'next-js',
        timeoutMs: 300000 // 5 minutes
      })
      
      if (sandboxSession.status === 'error') {
        throw new Error('Failed to create E2B sandbox')
      }

      // Deploy files to sandbox
      const deployResult = await e2bSandboxService.deployFiles(
        request.sessionId,
        request.files,
        '/home/user/project'
      )
      
      if (!deployResult.success) {
        throw new Error(`Failed to deploy files: ${deployResult.errors.join(', ')}`)
      }

      // Install dependencies if package.json exists
      const hasPackageJson = request.files.some(f => f.file_path === 'package.json')
      if (hasPackageJson) {
        await e2bSandboxService.executeCommand(
          request.sessionId,
          'npm install',
          { workingDir: '/home/user/project', timeout: 120000 }
        )
      }

      // Execute the code based on entry point
      let executionResult
      if (request.entryPoint.endsWith('.tsx') || request.entryPoint.endsWith('.jsx')) {
        // Start development server for React components
        const devServerResult = await e2bSandboxService.startDevServer(request.sessionId, {
          command: 'npm run dev',
          workingDir: '/home/user/project'
        })
        
        if (devServerResult.success) {
          executionResult = {
            stdout: `âœ… Development server started successfully\nURL: ${devServerResult.url}\nFiles deployed: ${deployResult.deployed}`,
            stderr: '',
            exitCode: 0
          }
        } else {
          executionResult = {
            stdout: '',
            stderr: devServerResult.error || 'Failed to start development server',
            exitCode: 1
          }
        }
      } else {
        // Execute file directly
        const command = this.getExecutionCommand(request.entryPoint)
        executionResult = await e2bSandboxService.executeCommand(
          request.sessionId,
          command,
          { workingDir: '/home/user/project', timeout: 60000 }
        )
      }
      
      const executionTime = Date.now() - startTime

      const result = {
        success: executionResult.exitCode === 0,
        output: executionResult.stdout || '',
        errors: executionResult.stderr ? [executionResult.stderr] : undefined,
        executionTime
      }

      await this.completeOperation(operationId, result)
      return result

    } catch (error) {
      const executionTime = Date.now() - startTime
      const errorMessage = error instanceof Error ? error.message : 'Unknown execution error'
      
      const result = {
        success: false,
        output: '',
        errors: [errorMessage],
        executionTime
      }

      await this.failOperation(operationId, errorMessage)
      return result
    }
  }

  // Removed generateMockOutput - now using real E2B execution

  // Helper methods for code generation (to be replaced with Claude Code SDK)
  
  private generateFrontendSpec(requirement: Requirement): string {
    return `
Frontend Implementation for: ${requirement.title}

## Component Structure
- Main component: ${this.pascalCase(requirement.title)}
- Props interface: ${this.pascalCase(requirement.title)}Props
- State management: React hooks

## Requirements
${requirement.description}

## Implementation Notes
- Use TypeScript for type safety
- Follow React best practices
- Implement responsive design with Tailwind CSS
- Add proper error handling and loading states
`
  }

  private generateBackendSpec(requirement: Requirement): string {
    return `
Backend Implementation for: ${requirement.title}

## API Endpoints
- GET /api/${this.kebabCase(requirement.title)}
- POST /api/${this.kebabCase(requirement.title)}
- PUT /api/${this.kebabCase(requirement.title)}/[id]
- DELETE /api/${this.kebabCase(requirement.title)}/[id]

## Database Schema
- Table: ${this.snakeCase(requirement.title)}
- Workspace isolation with RLS policies
- Proper indexing for performance

## Implementation Notes
- Use Next.js API routes
- Implement proper authentication and authorization
- Add comprehensive error handling
- Include request validation
`
  }

  private generateReactComponent(requirement: Requirement): string {
    const componentName = this.pascalCase(requirement.title)
    return `"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"

export interface ${componentName}Props {
  // Add props here
}

export function ${componentName}(props: ${componentName}Props) {
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Component logic here
  
  return (
    <Card>
      <CardHeader>
        <CardTitle>${requirement.title}</CardTitle>
      </CardHeader>
      <CardContent>
        <p>{/* ${requirement.description} */}</p>
        {error && (
          <div className="text-red-600 text-sm mt-2">
            {error}
          </div>
        )}
      </CardContent>
    </Card>
  )
}
`
  }

  private generateAPIRoute(requirement: Requirement): string {
    const routeName = this.kebabCase(requirement.title)
    return `import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import createServerClient from '@/lib/supabase/server'

// GET /api/${routeName}
export async function GET(request: NextRequest) {
  try {
    const cookieStore = cookies()
    const supabase = createServerClient(cookieStore)
    
    // Authentication check
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 })
    }

    // Implementation for ${requirement.title}
    // ${requirement.description}
    
    return NextResponse.json({ message: 'Success' })
  } catch (error) {
    console.error('API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// POST /api/${routeName}
export async function POST(request: NextRequest) {
  try {
    const cookieStore = cookies()
    const supabase = createServerClient(cookieStore)
    
    // Authentication check
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 })
    }

    const body = await request.json()
    
    // Implementation for ${requirement.title}
    // ${requirement.description}
    
    return NextResponse.json({ message: 'Created successfully' }, { status: 201 })
  } catch (error) {
    console.error('API error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
`
  }

  private generateTestFile(requirement: Requirement): string {
    const componentName = this.pascalCase(requirement.title)
    return `import { render, screen } from '@testing-library/react'
import { ${componentName} } from './${this.kebabCase(requirement.title)}'

describe('${componentName}', () => {
  it('renders without crashing', () => {
    render(<${componentName} />)
    expect(screen.getByText('${requirement.title}')).toBeInTheDocument()
  })

  it('handles ${requirement.description.toLowerCase()}', () => {
    // Test implementation for: ${requirement.description}
    // Add specific test cases here
  })
})
`
  }

  // Utility functions
  private kebabCase(str: string): string {
    return str.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '')
  }

  private pascalCase(str: string): string {
    return str.replace(/\w+/g, (w) => w[0].toUpperCase() + w.slice(1).toLowerCase()).replace(/\s+/g, '')
  }

  private snakeCase(str: string): string {
    return str.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '')
  }

  // New methods for Claude Code SDK integration
  
  private buildRequirementAnalysisPrompt(requirements: Requirement[]): string {
    return `
Analyze the following requirements and generate technical specifications:

${requirements.map(req => `
**Requirement: ${req.title}**
Description: ${req.description}
Priority: ${req.priority}
Category: ${req.category || 'general'}
Acceptance Criteria: ${JSON.stringify(req.acceptance_criteria)}
`).join('\n')}

For each requirement, provide:
1. Frontend implementation details (React/TypeScript components)
2. Backend implementation details (Next.js API routes)
3. Database schema requirements
4. Dependencies needed
5. Code examples

Respond in JSON format with technical specifications.
`
  }

  private parseAnalysisResponse(response: string, requirements: Requirement[]): TechnicalSpec[] {
    try {
      const parsed = JSON.parse(response)
      const techSpecs: TechnicalSpec[] = []
      
      for (const requirement of requirements) {
        const spec = parsed.specifications?.find((s: any) => 
          s.requirement_title === requirement.title
        )
        
        if (spec) {
          if (spec.frontend) {
            techSpecs.push({
              id: crypto.randomUUID(),
              session_id: this.config!.sessionId,
              workspace_id: this.config!.workspaceId,
              requirement_id: requirement.id,
              category: 'frontend',
              title: spec.frontend.title || `Frontend for ${requirement.title}`,
              description: spec.frontend.description || '',
              implementation_details: spec.frontend.implementation_details || '',
              code_examples: spec.frontend.code_examples || [],
              dependencies: spec.frontend.dependencies || [],
              generated_by_claude: true,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
          }
          
          if (spec.backend) {
            techSpecs.push({
              id: crypto.randomUUID(),
              session_id: this.config!.sessionId,
              workspace_id: this.config!.workspaceId,
              requirement_id: requirement.id,
              category: 'backend',
              title: spec.backend.title || `Backend for ${requirement.title}`,
              description: spec.backend.description || '',
              implementation_details: spec.backend.implementation_details || '',
              code_examples: spec.backend.code_examples || [],
              dependencies: spec.backend.dependencies || [],
              generated_by_claude: true,
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
          }
        }
      }
      
      return techSpecs
    } catch (error) {
      console.error('Failed to parse Claude analysis response:', error)
      // Fallback to generating basic specs
      return this.generateFallbackSpecs(requirements)
    }
  }

  private buildCodeGenerationPrompt(request: CodeGenerationRequest): string {
    return `
Generate production-ready code for the following requirements:

${request.requirements.map(req => `
**Requirement: ${req.title}**
${req.description}
`).join('\n')}

**Technical Specifications:**
${request.techSpecs?.map(spec => `
- ${spec.category}: ${spec.title}
  ${spec.description}
  Implementation: ${spec.implementation_details}
`).join('\n') || 'Use best practices'}

**Requirements:**
- Use Next.js 15+ with App Router
- TypeScript with strict mode
- TailwindCSS for styling
- shadcn/ui components
- Supabase for database operations
- Include proper error handling
- Add loading states
- Implement workspace isolation
${request.generateTests ? '- Generate test files using Vitest' : ''}

Generate complete, production-ready files with proper imports and exports.
`
  }

  private parseCodeGenerationResponse(response: any): Array<{
    path: string
    content: string
    type: string
    description: string
  }> {
    try {
      if (response.generatedFiles) {
        return response.generatedFiles
      }
      
      // Try to extract files from Claude's response
      const files = []
      const fileRegex = /```(\w+)\s*\/\/ ([\w\/.-]+)\n([\s\S]*?)```/g
      let match
      
      while ((match = fileRegex.exec(response.content || response)) !== null) {
        const [, language, path, content] = match
        files.push({
          path: path.startsWith('/') ? path.substring(1) : path,
          content: content.trim(),
          type: this.getFileType(path),
          description: `Generated ${language} file`
        })
      }
      
      return files
    } catch (error) {
      console.error('Failed to parse code generation response:', error)
      return []
    }
  }

  private buildCodeUpdatePrompt(requirementId: string, changes: Partial<Requirement>): string {
    return `
Update existing code based on requirement changes:

**Requirement ID:** ${requirementId}
**Changes:** ${JSON.stringify(changes, null, 2)}

Analyze the existing codebase and update relevant files to reflect these changes.
Maintain code quality and consistency.
`
  }

  private parseCodeUpdateResponse(response: any): CodeGenerationResult {
    try {
      return {
        generatedFiles: this.parseCodeGenerationResponse(response),
        testsGenerated: false,
        documentsUpdated: response.documentsUpdated || []
      }
    } catch (error) {
      console.error('Failed to parse code update response:', error)
      return {
        generatedFiles: [],
        testsGenerated: false,
        documentsUpdated: []
      }
    }
  }

  private generateFallbackSpecs(requirements: Requirement[]): TechnicalSpec[] {
    const techSpecs: TechnicalSpec[] = []
    
    for (const requirement of requirements) {
      // Frontend fallback spec
      techSpecs.push({
        id: crypto.randomUUID(),
        session_id: this.config!.sessionId,
        workspace_id: this.config!.workspaceId,
        requirement_id: requirement.id,
        category: 'frontend',
        title: `React Components for ${requirement.title}`,
        description: `Frontend implementation for ${requirement.description}`,
        implementation_details: this.generateFrontendSpec(requirement),
        code_examples: [
          {
            language: 'typescript',
            code: this.generateReactComponent(requirement),
            description: 'Main component implementation'
          }
        ],
        dependencies: ['react', 'typescript', 'tailwindcss'],
        generated_by_claude: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
    }
    
    return techSpecs
  }

  private getFileType(filePath: string): string {
    if (filePath.includes('/components/')) return 'component'
    if (filePath.includes('/api/')) return 'api'
    if (filePath.includes('.test.')) return 'test'
    if (filePath.includes('.spec.')) return 'test'
    if (filePath.endsWith('.sql')) return 'schema'
    if (filePath.endsWith('.json')) return 'config'
    return 'file'
  }

  private getExecutionCommand(entryPoint: string): string {
    if (entryPoint.endsWith('.ts')) {
      return `npx ts-node ${entryPoint}`
    }
    if (entryPoint.endsWith('.js')) {
      return `node ${entryPoint}`
    }
    if (entryPoint.endsWith('.tsx') || entryPoint.endsWith('.jsx')) {
      return 'npm run dev'
    }
    return `cat ${entryPoint}`
  }
}

// Factory function to create Claude agent instance
export function createClaudeAgent(config: ClaudeAgentConfig): ClaudeAgent {
  return new ClaudeAgent(config)
}